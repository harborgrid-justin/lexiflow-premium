{
  "auditMetadata": {
    "agent": "Enterprise Agent 5: DATABASE AUDIT AGENT",
    "auditDate": "2025-12-27",
    "applicationValue": "$350M Legal Enterprise Application",
    "totalEntities": 107,
    "totalMigrations": 17,
    "databaseType": "PostgreSQL",
    "ormFramework": "TypeORM"
  },

  "executiveSummary": {
    "overallScore": "C+ (72/100)",
    "criticalIssues": 8,
    "highPriorityIssues": 15,
    "mediumPriorityIssues": 23,
    "lowPriorityIssues": 12,
    "strengths": [
      "UUID primary keys consistently used across entities",
      "Comprehensive audit trail with createdAt, updatedAt, createdBy, updatedBy",
      "Soft delete implementation with deletedAt column",
      "Enterprise-grade connection pooling configuration",
      "Transaction management service with retry logic and savepoints",
      "Query optimizer service with N+1 detection",
      "SSL/TLS encryption enforced",
      "Row-level security policies enabled on users table"
    ],
    "criticalWeaknesses": [
      "CRITICAL: synchronize:true in data-source.ts - MUST BE FALSE IN PRODUCTION",
      "CRITICAL: Mixed naming conventions (camelCase vs snake_case)",
      "CRITICAL: Inconsistent BaseEntity usage - some entities reimplementing audit columns",
      "CRITICAL: Missing foreign key constraints on many relationships",
      "HIGH: No composite indexes on high-traffic query patterns",
      "HIGH: Evidence entity using varchar instead of enum type",
      "HIGH: Missing indexes on deletedAt for soft-delete performance",
      "HIGH: No database-level check constraints on critical business rules"
    ]
  },

  "entityIssues": [
    {
      "severity": "CRITICAL",
      "entity": "/home/user/lexiflow-premium/backend/src/config/data-source.ts",
      "issue": "synchronize: true in production configuration",
      "description": "Line 13 and 38 have 'synchronize: true' which auto-creates/modifies tables. This is EXTREMELY DANGEROUS in production and can cause data loss.",
      "impact": "Data loss, schema corruption, downtime",
      "recommendation": "IMMEDIATELY set synchronize: false and use migrations exclusively",
      "lines": [13, 38]
    },
    {
      "severity": "CRITICAL",
      "entity": "/home/user/lexiflow-premium/backend/src/discovery/custodians/entities/custodian.entity.ts",
      "issue": "Not extending BaseEntity - reimplementing audit columns",
      "description": "Custodian entity manually implements createdAt, updatedAt, deletedAt, createdBy, updatedBy instead of extending BaseEntity. This violates DRY and creates inconsistency.",
      "impact": "Code duplication, inconsistent audit behavior, maintenance overhead",
      "recommendation": "Extend BaseEntity and remove duplicate column definitions",
      "lines": [1, 114, 117, 120, 126]
    },
    {
      "severity": "CRITICAL",
      "entity": "/home/user/lexiflow-premium/backend/src/billing/trust-accounts/entities/trust-account.entity.ts",
      "issue": "Not extending BaseEntity - reimplementing audit columns",
      "description": "TrustAccount entity manually implements all audit columns instead of extending BaseEntity. Creates inconsistency across codebase.",
      "impact": "Code duplication, inconsistent audit behavior",
      "recommendation": "Extend BaseEntity from common/base/base.entity.ts",
      "lines": [28, 149, 152, 155, 158, 161]
    },
    {
      "severity": "HIGH",
      "entity": "/home/user/lexiflow-premium/backend/src/invoices/entities/invoice.entity.ts",
      "issue": "Duplicates createdBy/updatedBy despite extending BaseEntity",
      "description": "Lines 175-179 redefine createdBy and updatedBy which are already inherited from BaseEntity (lines 31-37 of BaseEntity). This creates duplicate columns.",
      "impact": "Schema conflicts, duplicate columns in database",
      "recommendation": "Remove duplicate createdBy/updatedBy column definitions",
      "lines": [175, 176, 178, 179]
    },
    {
      "severity": "HIGH",
      "entity": "/home/user/lexiflow-premium/backend/src/documents/entities/document.entity.ts",
      "issue": "Duplicates createdBy/updatedBy despite extending BaseEntity",
      "description": "Lines 99-103 redefine createdBy and updatedBy which are already inherited from BaseEntity",
      "impact": "Schema conflicts, duplicate columns in database",
      "recommendation": "Remove duplicate createdBy/updatedBy column definitions",
      "lines": [99, 100, 102, 103]
    },
    {
      "severity": "HIGH",
      "entity": "/home/user/lexiflow-premium/backend/src/discovery/evidence/entities/evidence.entity.ts",
      "issue": "Using varchar instead of enum type for enum columns",
      "description": "Lines 46-50 define 'type' as varchar with default value instead of using proper enum type. Same for admissibility (lines 67-71). This bypasses database-level constraints.",
      "impact": "No database validation, potential invalid data",
      "recommendation": "Use proper enum type: type: 'enum', enum: EvidenceType",
      "lines": [46, 47, 48, 49, 67, 68, 69]
    },
    {
      "severity": "HIGH",
      "entity": "/home/user/lexiflow-premium/backend/src/common/base/base.entity.ts",
      "issue": "Missing database-level index on deletedAt",
      "description": "DeleteDateColumn at line 27 has no index. All soft-delete queries will perform full table scans when filtering WHERE deletedAt IS NULL",
      "impact": "Severe performance degradation on large tables with soft deletes",
      "recommendation": "Add @Index() decorator to deletedAt column",
      "lines": [27]
    },
    {
      "severity": "MEDIUM",
      "entity": "/home/user/lexiflow-premium/backend/src/cases/entities/case.entity.ts",
      "issue": "Missing composite index on (clientId, status)",
      "description": "Lines 44 and 45 define separate indexes on clientId and status, but common query pattern 'find active cases for client' would benefit from composite index",
      "impact": "Suboptimal query performance on client case listings",
      "recommendation": "Add @Index(['clientId', 'status'])",
      "lines": [44, 45]
    },
    {
      "severity": "MEDIUM",
      "entity": "/home/user/lexiflow-premium/backend/src/cases/entities/case.entity.ts",
      "issue": "Missing index on filingDate, trialDate, closeDate",
      "description": "Date columns (lines 100-107) used for filtering and sorting have no indexes",
      "impact": "Slow date-range queries and chronological sorting",
      "recommendation": "Add indexes on frequently queried date columns",
      "lines": [100, 103, 106]
    },
    {
      "severity": "MEDIUM",
      "entity": "/home/user/lexiflow-premium/backend/src/billing/invoices/entities/invoice.entity.ts",
      "issue": "No check constraint on financial amounts",
      "description": "Decimal columns (lines 100-119) for monetary amounts have no CHECK constraints to prevent negative values where inappropriate",
      "impact": "Invalid financial data (negative invoices, negative payments)",
      "recommendation": "Add CHECK constraints: CHECK (total_amount >= 0), CHECK (paid_amount >= 0)",
      "lines": [100, 112, 115, 118]
    },
    {
      "severity": "MEDIUM",
      "entity": "/home/user/lexiflow-premium/backend/src/clients/entities/client.entity.ts",
      "issue": "Missing composite index on (status, email)",
      "description": "Queries filtering active clients by email would benefit from composite index",
      "impact": "Slower client lookups in authentication/portal access",
      "recommendation": "Add @Index(['status', 'email'])",
      "lines": [9, 10]
    },
    {
      "severity": "MEDIUM",
      "entity": "/home/user/lexiflow-premium/backend/src/auth/entities/session.entity.ts",
      "issue": "Missing composite index on (userId, isActive)",
      "description": "Common pattern 'get active sessions for user' requires composite index",
      "impact": "Slow session validation and user logout operations",
      "recommendation": "Add @Index(['userId', 'isActive'])",
      "lines": [6, 9]
    },
    {
      "severity": "MEDIUM",
      "entity": "/home/user/lexiflow-premium/backend/src/billing/time-entries/entities/time-entry.entity.ts",
      "issue": "Missing index on (invoiceId, status) for billing queries",
      "description": "Queries finding time entries for invoices by status have no composite index",
      "impact": "Slow invoice generation and billing reports",
      "recommendation": "Add @Index(['invoiceId', 'status'])",
      "lines": [78, 79, 72]
    },
    {
      "severity": "MEDIUM",
      "entity": "/home/user/lexiflow-premium/backend/src/compliance/entities/audit-log.entity.ts",
      "issue": "Missing composite index on (timestamp, action) for audit queries",
      "description": "Time-series queries filtering by action type have no composite index",
      "impact": "Slow compliance reporting and security audits",
      "recommendation": "Add @Index(['timestamp', 'action', 'entityType'])",
      "lines": [9, 7, 8]
    },
    {
      "severity": "LOW",
      "entity": "/home/user/lexiflow-premium/backend/src/users/entities/user.entity.ts",
      "issue": "Phone and department columns have inconsistent length constraints",
      "description": "Line 70 defines phone as varchar(20) but line 77 defines department as varchar(100). Phone should be longer for international formats.",
      "impact": "Potential data truncation for international phone numbers",
      "recommendation": "Increase phone to varchar(50) to support +countrycode and extensions",
      "lines": [70, 77]
    },
    {
      "severity": "LOW",
      "entity": "/home/user/lexiflow-premium/backend/src/parties/entities/party.entity.ts",
      "issue": "Enum definitions have duplicate values in different cases",
      "description": "PartyType enum has both 'OTHER' and 'OTHER_LOWER = other'. This creates confusion and potential bugs.",
      "impact": "Type confusion, inconsistent enum usage across codebase",
      "recommendation": "Use single consistent enum value per concept (prefer snake_case for database)",
      "lines": [5, 19, 20]
    }
  ],

  "indexingRecommendations": [
    {
      "priority": "CRITICAL",
      "table": "All tables with soft delete",
      "recommendation": "Add index on deletedAt column in BaseEntity",
      "rationale": "Every soft-delete query includes WHERE deletedAt IS NULL. Without index, this causes full table scans on every query.",
      "estimatedPerformanceGain": "80-95% for queries on large tables",
      "implementation": "Add @Index() decorator to deletedAt in /home/user/lexiflow-premium/backend/src/common/base/base.entity.ts line 27"
    },
    {
      "priority": "HIGH",
      "table": "cases",
      "recommendation": "Add composite index: INDEX idx_cases_client_status ON cases(client_id, status)",
      "rationale": "Common query pattern: Get all active cases for a client. Current separate indexes inefficient.",
      "estimatedPerformanceGain": "60-70%",
      "implementation": "@Index(['clientId', 'status'])"
    },
    {
      "priority": "HIGH",
      "table": "sessions",
      "recommendation": "Add composite index: INDEX idx_sessions_user_active ON sessions(user_id, is_active, expires_at)",
      "rationale": "Session validation queries check user + active status + expiration frequently",
      "estimatedPerformanceGain": "70-80%",
      "implementation": "@Index(['userId', 'isActive', 'expiresAt'])"
    },
    {
      "priority": "HIGH",
      "table": "invoices",
      "recommendation": "Add composite index: INDEX idx_invoices_status_due ON invoices(status, due_date) WHERE status != 'paid'",
      "rationale": "Overdue invoice detection and aging reports query by status and due date",
      "estimatedPerformanceGain": "65-75%",
      "implementation": "@Index(['status', 'dueDate']) with partial index WHERE status != 'paid'"
    },
    {
      "priority": "HIGH",
      "table": "time_entries",
      "recommendation": "Add composite index: INDEX idx_time_entries_user_date ON time_entries(user_id, date DESC, status)",
      "rationale": "Timesheet queries: get recent entries for user by status",
      "estimatedPerformanceGain": "70-80%",
      "implementation": "@Index(['userId', 'date', 'status'])"
    },
    {
      "priority": "MEDIUM",
      "table": "audit_logs",
      "recommendation": "Add composite index: INDEX idx_audit_logs_time_series ON audit_logs(timestamp DESC, entity_type, action) WHERE is_archived = false",
      "rationale": "Compliance reports query recent activity by entity type and action",
      "estimatedPerformanceGain": "50-60%",
      "implementation": "@Index(['timestamp', 'entityType', 'action']) with DESC on timestamp"
    },
    {
      "priority": "MEDIUM",
      "table": "documents",
      "recommendation": "Add composite index: INDEX idx_documents_case_status ON documents(case_id, status, created_at DESC)",
      "rationale": "Case document listings filter by status and sort by creation date",
      "estimatedPerformanceGain": "55-65%",
      "implementation": "@Index(['caseId', 'status', 'createdAt'])"
    },
    {
      "priority": "MEDIUM",
      "table": "cases",
      "recommendation": "Add indexes on date columns: INDEX idx_cases_filing_date ON cases(filing_date), INDEX idx_cases_trial_date ON cases(trial_date)",
      "rationale": "Calendar views and deadline tracking query by these dates",
      "estimatedPerformanceGain": "40-50%",
      "implementation": "@Index() on filingDate, trialDate, closeDate columns"
    },
    {
      "priority": "LOW",
      "table": "clients",
      "recommendation": "Add covering index: INDEX idx_clients_active_portal ON clients(status, email) INCLUDE (id, name, portal_token)",
      "rationale": "Client portal authentication can use index-only scan",
      "estimatedPerformanceGain": "30-40%",
      "implementation": "Requires PostgreSQL 11+ INCLUDE clause in migration"
    },
    {
      "priority": "LOW",
      "table": "evidence",
      "recommendation": "Add GIN index: INDEX idx_evidence_tags ON evidence USING GIN(tags)",
      "rationale": "Tag-based evidence search uses array operations",
      "estimatedPerformanceGain": "60-70% for tag searches",
      "implementation": "@Index() with type: 'GIN' for jsonb/array columns"
    }
  ],

  "relationshipIssues": [
    {
      "severity": "HIGH",
      "entity": "Case -> Client relationship",
      "file": "/home/user/lexiflow-premium/backend/src/cases/entities/case.entity.ts",
      "issue": "ManyToOne relationship missing onDelete behavior",
      "description": "Line 130-132: Relationship to Client has nullable: true but no onDelete specified. Default is RESTRICT which prevents client deletion.",
      "impact": "Cannot delete clients with cases, orphaned data risk",
      "recommendation": "Add onDelete: 'SET NULL' or onDelete: 'CASCADE' based on business rules",
      "lines": [130, 131]
    },
    {
      "severity": "MEDIUM",
      "entity": "Document -> Case relationship",
      "file": "/home/user/lexiflow-premium/backend/src/documents/entities/document.entity.ts",
      "issue": "Cascade delete on document when case deleted",
      "description": "Line 35: onDelete: 'CASCADE' means all documents deleted when case deleted. No audit trail.",
      "impact": "Permanent data loss, regulatory compliance risk for legal documents",
      "recommendation": "Use soft delete or archive pattern instead of CASCADE",
      "lines": [35]
    },
    {
      "severity": "MEDIUM",
      "entity": "Invoice -> Case relationship",
      "file": "/home/user/lexiflow-premium/backend/src/billing/invoices/entities/invoice.entity.ts",
      "issue": "Foreign key allows NULL but relationship not properly typed",
      "description": "Line 48 caseId is nullable, but line 54 case property uses ! (non-null assertion). Type mismatch.",
      "impact": "Runtime null errors, type safety violation",
      "recommendation": "Make case property optional: case?: Case",
      "lines": [48, 54]
    },
    {
      "severity": "MEDIUM",
      "entity": "TimeEntry -> User relationship",
      "file": "/home/user/lexiflow-premium/backend/src/billing/time-entries/entities/time-entry.entity.ts",
      "issue": "Missing eager loading strategy for frequently accessed relation",
      "description": "Line 42-44: User relationship not eagerly loaded. Time entry lists require N+1 queries to get user names.",
      "impact": "N+1 query problem, severe performance degradation on time entry lists",
      "recommendation": "Consider eager: true or use QueryBuilder with leftJoinAndSelect",
      "lines": [42, 43, 44]
    },
    {
      "severity": "LOW",
      "entity": "Session -> User relationship",
      "file": "/home/user/lexiflow-premium/backend/src/auth/entities/session.entity.ts",
      "issue": "Cascade delete appropriate but no soft delete",
      "description": "Line 75 onDelete: CASCADE is appropriate for sessions, but no deleted_at for audit trail",
      "impact": "Loss of session history for security audits",
      "recommendation": "Add soft delete to sessions for 90-day retention before permanent deletion",
      "lines": [75]
    }
  ],

  "migrationIssues": [
    {
      "severity": "CRITICAL",
      "file": "/home/user/lexiflow-premium/backend/src/config/data-source.ts",
      "issue": "synchronize: true enables auto-sync in production",
      "description": "Lines 13 and 38 set synchronize: true. Combined with migrationsRun: false, this bypasses migration control and can corrupt production database.",
      "impact": "CATASTROPHIC - Data loss, schema corruption, regulatory violations",
      "recommendation": "Set synchronize: false, migrationsRun: true, use migrations exclusively",
      "lines": [13, 38]
    },
    {
      "severity": "CRITICAL",
      "file": "/home/user/lexiflow-premium/backend/src/config/data-source.ts",
      "issue": "Naming strategy commented out, causing snake_case/camelCase mismatch",
      "description": "Line 2 imports SnakeNamingStrategy but line 17 and 42 comment it out. This creates inconsistency between entity properties and database columns.",
      "impact": "Query failures, column not found errors, data corruption",
      "recommendation": "Enable SnakeNamingStrategy OR standardize all entities to match database naming",
      "lines": [2, 17, 42]
    },
    {
      "severity": "HIGH",
      "file": "/home/user/lexiflow-premium/backend/src/database/migrations/1766016707290-CreateClientsTable.ts",
      "issue": "Unsafe migration: Drops indexes before modifying columns",
      "description": "Lines 8, 18-20, 31-32, 40: Migration drops indexes, then modifies columns, then recreates indexes. If migration fails mid-execution, indexes are lost.",
      "impact": "Performance degradation, index loss on failed migration",
      "recommendation": "Drop indexes AFTER column modifications or use CREATE INDEX CONCURRENTLY",
      "lines": [8, 18, 19, 20, 31, 32, 40]
    },
    {
      "severity": "HIGH",
      "file": "/home/user/lexiflow-premium/backend/src/database/migrations/1766151200000-AddCreatedByUpdatedBy.ts",
      "issue": "Migration uses varchar instead of uuid for created_by/updated_by",
      "description": "Lines 13 and 23: Migration adds created_by and updated_by as varchar, but they should be uuid to match user IDs",
      "impact": "Type mismatch, foreign key constraint failures, invalid data",
      "recommendation": "Change type to 'uuid' to match user.id primary key",
      "lines": [13, 23]
    },
    {
      "severity": "MEDIUM",
      "file": "/home/user/lexiflow-premium/backend/src/database/migrations/1734480500000-CreateJurisdictionTables.ts",
      "issue": "Migration uses camelCase column names instead of snake_case",
      "description": "Lines 9-22: Migration creates columns with camelCase (createdAt, updatedAt, rulesUrl) instead of enterprise standard snake_case",
      "impact": "Inconsistent naming convention across database schema",
      "recommendation": "Use snake_case: created_at, updated_at, rules_url for all column names",
      "lines": [9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]
    },
    {
      "severity": "MEDIUM",
      "file": "/home/user/lexiflow-premium/backend/src/database/migrations/1735336800000-AddDatabaseSecurityEnhancements.ts",
      "issue": "Migration enables RLS but creates overly restrictive default policy",
      "description": "Lines 107-113: Row Level Security policy restricts users to only see their own data, but this breaks admin and cross-user queries",
      "impact": "Application errors, admin users cannot manage other users",
      "recommendation": "Create role-based RLS policies: admins see all, users see own + assigned",
      "lines": [107, 108, 109, 110, 111, 112, 113]
    },
    {
      "severity": "LOW",
      "file": "/home/user/lexiflow-premium/backend/src/database/migrations/1734480500000-CreateJurisdictionTables.ts",
      "issue": "Migration hardcodes seed data in migration",
      "description": "Lines 58-89: Seed data for jurisdictions is in migration file. This couples data with schema changes.",
      "impact": "Difficult to manage seed data, migrations become bloated",
      "recommendation": "Move seed data to separate seeder files, keep migrations schema-only",
      "lines": [58, 59, 60, 61, 62, 63, 64, 65]
    }
  ],

  "codeChanges": [
    {
      "priority": "CRITICAL",
      "file": "/home/user/lexiflow-premium/backend/src/config/data-source.ts",
      "description": "Fix CRITICAL production safety issue - disable synchronize",
      "currentCode": "      synchronize: true, // TEMPORARY: Auto-create tables - matches existing camelCase schema\n      migrationsRun: false,",
      "newCode": "      synchronize: false, // PRODUCTION SAFETY: Never auto-sync schema\n      migrationsRun: true, // Run migrations on startup",
      "rationale": "synchronize:true can destroy production data. MUST use migrations for all schema changes.",
      "lines": [13, 14, 38, 39]
    },
    {
      "priority": "CRITICAL",
      "file": "/home/user/lexiflow-premium/backend/src/common/base/base.entity.ts",
      "description": "Add critical index on deletedAt for soft-delete performance",
      "currentCode": "  @ApiProperty({ example: null, nullable: true })\n  @DeleteDateColumn({ name: 'deleted_at', nullable: true })\n  @Transform(({ value }: { value?: Date }) => value?.toISOString(), { toPlainOnly: true })\n  deletedAt?: Date;",
      "newCode": "  @ApiProperty({ example: null, nullable: true })\n  @DeleteDateColumn({ name: 'deleted_at', nullable: true })\n  @Index() // CRITICAL: Index for WHERE deletedAt IS NULL queries\n  @Transform(({ value }: { value?: Date }) => value?.toISOString(), { toPlainOnly: true })\n  deletedAt?: Date;",
      "rationale": "Every query on entities with soft delete includes WHERE deletedAt IS NULL. Without index, full table scan on every query.",
      "lines": [26, 27, 28, 29]
    },
    {
      "priority": "CRITICAL",
      "file": "/home/user/lexiflow-premium/backend/src/discovery/custodians/entities/custodian.entity.ts",
      "description": "Fix entity inheritance - extend BaseEntity instead of reimplementing",
      "currentCode": "@Entity('custodians')\nexport class Custodian {\n  @PrimaryGeneratedColumn('uuid')\n  id!: string;\n\n  // ... entity fields ...\n\n  @Column({ name: 'created_by', type: 'uuid' })\n  createdBy!: string;\n\n  @Column({ name: 'updated_by', type: 'uuid', nullable: true })\n  updatedBy!: string;\n\n  @CreateDateColumn({ name: 'created_at' })\n  createdAt!: Date;\n\n  @UpdateDateColumn({ name: 'updated_at' })\n  updatedAt!: Date;\n\n  @Column({ name: 'deleted_at', type: 'timestamp', nullable: true })\n  deletedAt!: Date;\n}",
      "newCode": "import { BaseEntity } from '../../../common/base/base.entity';\n\n@Entity('custodians')\nexport class Custodian extends BaseEntity {\n  // Remove duplicate audit columns - inherited from BaseEntity:\n  // - id (uuid primary key)\n  // - createdAt, updatedAt, deletedAt\n  // - createdBy, updatedBy\n\n  @Column({ name: 'case_id', type: 'uuid' })\n  caseId!: string;\n\n  // ... rest of entity fields ...\n}",
      "rationale": "Violates DRY principle, creates inconsistent audit behavior. BaseEntity provides standardized audit columns.",
      "lines": [1, 18, 19, 114, 117, 120, 126]
    },
    {
      "priority": "HIGH",
      "file": "/home/user/lexiflow-premium/backend/src/billing/invoices/entities/invoice.entity.ts",
      "description": "Remove duplicate createdBy/updatedBy columns already inherited from BaseEntity",
      "currentCode": "  @Column({ name: 'pdf_url', type: 'varchar', length: 255, nullable: true })\n  pdfUrl!: string;\n\n  @Column({ type: 'simple-array', nullable: true })\n  attachments!: string[];\n\n  @Column({ name: 'created_by', type: 'uuid', nullable: true })\n  createdBy!: string;\n\n  @Column({ name: 'updated_by', type: 'uuid', nullable: true })\n  updatedBy!: string;\n\n  @VersionColumn()\n  version!: number;",
      "newCode": "  @Column({ name: 'pdf_url', type: 'varchar', length: 255, nullable: true })\n  pdfUrl!: string;\n\n  @Column({ type: 'simple-array', nullable: true })\n  attachments!: string[];\n\n  // createdBy and updatedBy inherited from BaseEntity - removed duplicates\n\n  @VersionColumn()\n  version!: number;",
      "rationale": "Invoice extends BaseEntity which already provides createdBy/updatedBy. Duplicates cause schema errors.",
      "lines": [175, 176, 178, 179]
    },
    {
      "priority": "HIGH",
      "file": "/home/user/lexiflow-premium/backend/src/cases/entities/case.entity.ts",
      "description": "Add composite indexes for common query patterns",
      "currentCode": "@Index(['status'])\n@Index(['practiceArea'])\n@Index(['jurisdiction'])\n@Index(['assignedTeamId'])\n@Index(['leadAttorneyId'])\n@Index(['clientId'])\n@Index(['isArchived'])\nexport class Case extends BaseEntity {",
      "newCode": "@Index(['status'])\n@Index(['practiceArea'])\n@Index(['jurisdiction'])\n@Index(['assignedTeamId'])\n@Index(['leadAttorneyId'])\n@Index(['clientId'])\n@Index(['isArchived'])\n// Composite indexes for common query patterns\n@Index(['clientId', 'status']) // Get active cases for client\n@Index(['status', 'trialDate']) // Upcoming trials\n@Index(['filingDate']) // Chronological sorting\n@Index(['trialDate']) // Trial calendar\nexport class Case extends BaseEntity {",
      "rationale": "Composite indexes dramatically improve performance for multi-column WHERE clauses",
      "lines": [39, 40, 41, 42, 43, 44, 45]
    },
    {
      "priority": "HIGH",
      "file": "/home/user/lexiflow-premium/backend/src/discovery/evidence/entities/evidence.entity.ts",
      "description": "Fix enum type definition - use proper TypeORM enum instead of varchar",
      "currentCode": "  @Column({\n    type: 'varchar',\n    default: EvidenceType.DOCUMENT,\n  })\n  type!: EvidenceType;\n\n  // ...\n\n  @Column({\n    type: 'varchar',\n    default: AdmissibilityStatus.PENDING,\n  })\n  admissibility!: AdmissibilityStatus;",
      "newCode": "  @Column({\n    type: 'enum',\n    enum: EvidenceType,\n    default: EvidenceType.DOCUMENT,\n  })\n  type!: EvidenceType;\n\n  // ...\n\n  @Column({\n    type: 'enum',\n    enum: AdmissibilityStatus,\n    default: AdmissibilityStatus.PENDING,\n  })\n  admissibility!: AdmissibilityStatus;",
      "rationale": "varchar allows invalid enum values. Database-level enum type enforces data integrity.",
      "lines": [46, 47, 48, 49, 67, 68, 69]
    },
    {
      "priority": "HIGH",
      "file": "/home/user/lexiflow-premium/backend/src/auth/entities/session.entity.ts",
      "description": "Add composite indexes for session validation performance",
      "currentCode": "@Index(['userId'])\n@Index(['token'], { unique: true })\n@Index(['expiresAt'])\n@Index(['isActive'])\nexport class Session extends BaseEntity {",
      "newCode": "@Index(['userId'])\n@Index(['token'], { unique: true })\n@Index(['expiresAt'])\n@Index(['isActive'])\n// Composite indexes for session validation\n@Index(['userId', 'isActive', 'expiresAt']) // Active session lookup\n@Index(['userId', 'isActive']) // User's active sessions\nexport class Session extends BaseEntity {",
      "rationale": "Session validation queries check user + active + expiration together. Composite index enables index-only scans.",
      "lines": [6, 7, 8, 9]
    },
    {
      "priority": "MEDIUM",
      "file": "/home/user/lexiflow-premium/backend/src/billing/time-entries/entities/time-entry.entity.ts",
      "description": "Add composite indexes for billing and timesheet queries",
      "currentCode": "@Index(['caseId', 'date'])\n@Index(['userId', 'status'])\n@Index(['status', 'billable'])\nexport class TimeEntry extends BaseEntity {",
      "newCode": "@Index(['caseId', 'date'])\n@Index(['userId', 'status'])\n@Index(['status', 'billable'])\n// Additional composite indexes for performance\n@Index(['userId', 'date', 'status']) // Timesheet queries with date sorting\n@Index(['invoiceId', 'status']) // Invoice time entry lookup\n@Index(['caseId', 'billable', 'status']) // Billable hours reports\nexport class TimeEntry extends BaseEntity {",
      "rationale": "Billing reports and timesheet queries require efficient multi-column filtering",
      "lines": [26, 27, 28]
    },
    {
      "priority": "MEDIUM",
      "file": "NEW FILE: /home/user/lexiflow-premium/backend/src/database/migrations/1735500000000-AddCriticalIndexes.ts",
      "description": "Create migration to add all critical missing indexes",
      "currentCode": "// NEW FILE",
      "newCode": "import { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class AddCriticalIndexes1735500000000 implements MigrationInterface {\n  name = 'AddCriticalIndexes1735500000000';\n\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    // Add index on deletedAt for all soft-delete tables\n    await queryRunner.query(\n      `CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_cases_deleted_at ON cases(deleted_at) WHERE deleted_at IS NULL`\n    );\n    await queryRunner.query(\n      `CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_invoices_deleted_at ON invoices(deleted_at) WHERE deleted_at IS NULL`\n    );\n    await queryRunner.query(\n      `CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_clients_deleted_at ON clients(deleted_at) WHERE deleted_at IS NULL`\n    );\n\n    // Composite indexes for common queries\n    await queryRunner.query(\n      `CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_cases_client_status ON cases(client_id, status) WHERE deleted_at IS NULL`\n    );\n    await queryRunner.query(\n      `CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_sessions_user_active ON sessions(user_id, is_active, expires_at)`\n    );\n    await queryRunner.query(\n      `CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_time_entries_user_date ON time_entries(user_id, date DESC, status) WHERE deleted_at IS NULL`\n    );\n\n    console.log('✓ Critical indexes added successfully');\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`DROP INDEX CONCURRENTLY IF EXISTS idx_time_entries_user_date`);\n    await queryRunner.query(`DROP INDEX CONCURRENTLY IF EXISTS idx_sessions_user_active`);\n    await queryRunner.query(`DROP INDEX CONCURRENTLY IF EXISTS idx_cases_client_status`);\n    await queryRunner.query(`DROP INDEX CONCURRENTLY IF EXISTS idx_clients_deleted_at`);\n    await queryRunner.query(`DROP INDEX CONCURRENTLY IF EXISTS idx_invoices_deleted_at`);\n    await queryRunner.query(`DROP INDEX CONCURRENTLY IF EXISTS idx_cases_deleted_at`);\n  }\n}",
      "rationale": "CREATE INDEX CONCURRENTLY prevents table locking during index creation in production",
      "lines": []
    },
    {
      "priority": "MEDIUM",
      "file": "NEW FILE: /home/user/lexiflow-premium/backend/src/database/migrations/1735510000000-AddFinancialConstraints.ts",
      "description": "Add CHECK constraints for financial data integrity",
      "currentCode": "// NEW FILE",
      "newCode": "import { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class AddFinancialConstraints1735510000000 implements MigrationInterface {\n  name = 'AddFinancialConstraints1735510000000';\n\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    // Invoice financial constraints\n    await queryRunner.query(\n      `ALTER TABLE invoices ADD CONSTRAINT chk_invoice_total_positive CHECK (total_amount >= 0)`\n    );\n    await queryRunner.query(\n      `ALTER TABLE invoices ADD CONSTRAINT chk_invoice_paid_positive CHECK (paid_amount >= 0)`\n    );\n    await queryRunner.query(\n      `ALTER TABLE invoices ADD CONSTRAINT chk_invoice_balance CHECK (balance_due >= 0)`\n    );\n    await queryRunner.query(\n      `ALTER TABLE invoices ADD CONSTRAINT chk_invoice_paid_not_exceed_total CHECK (paid_amount <= total_amount)`\n    );\n\n    // Time entry constraints\n    await queryRunner.query(\n      `ALTER TABLE time_entries ADD CONSTRAINT chk_time_entry_duration_positive CHECK (duration > 0)`\n    );\n    await queryRunner.query(\n      `ALTER TABLE time_entries ADD CONSTRAINT chk_time_entry_rate_positive CHECK (rate >= 0)`\n    );\n    await queryRunner.query(\n      `ALTER TABLE time_entries ADD CONSTRAINT chk_time_entry_total CHECK (total >= 0)`\n    );\n\n    // Trust account constraints\n    await queryRunner.query(\n      `ALTER TABLE trust_accounts ADD CONSTRAINT chk_trust_balance_positive CHECK (balance >= 0)`\n    );\n    await queryRunner.query(\n      `ALTER TABLE trust_accounts ADD CONSTRAINT chk_trust_minimum_balance CHECK (minimum_balance >= 0)`\n    );\n\n    console.log('✓ Financial constraints added successfully');\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`ALTER TABLE trust_accounts DROP CONSTRAINT IF EXISTS chk_trust_minimum_balance`);\n    await queryRunner.query(`ALTER TABLE trust_accounts DROP CONSTRAINT IF EXISTS chk_trust_balance_positive`);\n    await queryRunner.query(`ALTER TABLE time_entries DROP CONSTRAINT IF EXISTS chk_time_entry_total`);\n    await queryRunner.query(`ALTER TABLE time_entries DROP CONSTRAINT IF EXISTS chk_time_entry_rate_positive`);\n    await queryRunner.query(`ALTER TABLE time_entries DROP CONSTRAINT IF EXISTS chk_time_entry_duration_positive`);\n    await queryRunner.query(`ALTER TABLE invoices DROP CONSTRAINT IF EXISTS chk_invoice_paid_not_exceed_total`);\n    await queryRunner.query(`ALTER TABLE invoices DROP CONSTRAINT IF EXISTS chk_invoice_balance`);\n    await queryRunner.query(`ALTER TABLE invoices DROP CONSTRAINT IF EXISTS chk_invoice_paid_positive`);\n    await queryRunner.query(`ALTER TABLE invoices DROP CONSTRAINT IF EXISTS chk_invoice_total_positive`);\n  }\n}",
      "rationale": "Database-level constraints prevent invalid financial data (negative amounts, overpayments, etc.)",
      "lines": []
    }
  ],

  "bestPracticeRecommendations": [
    {
      "category": "Naming Conventions",
      "recommendation": "Standardize on snake_case for all database columns",
      "currentState": "Mixed camelCase and snake_case across entities and migrations",
      "desiredState": "All database columns use snake_case (created_at, user_id, case_number)",
      "implementation": "Enable SnakeNamingStrategy in data-source.ts and update all entities",
      "priority": "HIGH"
    },
    {
      "category": "Entity Design",
      "recommendation": "All entities must extend BaseEntity",
      "currentState": "Some entities (Custodian, TrustAccount) reimplement audit columns",
      "desiredState": "Consistent inheritance from BaseEntity for all domain entities",
      "implementation": "Refactor Custodian and TrustAccount to extend BaseEntity",
      "priority": "HIGH"
    },
    {
      "category": "Soft Delete",
      "recommendation": "Add index on deletedAt and use partial indexes WHERE deleted_at IS NULL",
      "currentState": "No index on deletedAt - full table scans on every query",
      "desiredState": "Index on deletedAt with partial index for active records",
      "implementation": "Add @Index() to BaseEntity.deletedAt and create migration",
      "priority": "CRITICAL"
    },
    {
      "category": "Migration Safety",
      "recommendation": "Use CREATE INDEX CONCURRENTLY for production migrations",
      "currentState": "Migrations use blocking index creation",
      "desiredState": "Non-blocking index creation with CONCURRENTLY",
      "implementation": "All index creation migrations use CONCURRENTLY clause",
      "priority": "HIGH"
    },
    {
      "category": "Transaction Patterns",
      "recommendation": "Use TransactionManagerService for all multi-step operations",
      "currentState": "Good - TransactionManagerService exists with retry and savepoint support",
      "desiredState": "Consistently used across all services for data modifications",
      "implementation": "Audit all services to ensure transaction usage for critical operations",
      "priority": "MEDIUM"
    },
    {
      "category": "Query Optimization",
      "recommendation": "Use QueryOptimizerService for all complex queries",
      "currentState": "QueryOptimizerService exists with N+1 detection",
      "desiredState": "Integrated into all repository patterns and services",
      "implementation": "Add QueryOptimizer as default for all createQueryBuilder calls",
      "priority": "MEDIUM"
    },
    {
      "category": "Connection Pooling",
      "recommendation": "Current configuration excellent - maintain settings",
      "currentState": "Max: 20, Min: 5, idle timeout: 30s, statement timeout: 60s",
      "desiredState": "Current configuration appropriate for enterprise scale",
      "implementation": "Monitor pool exhaustion and adjust max connections if needed",
      "priority": "LOW"
    },
    {
      "category": "Data Integrity",
      "recommendation": "Add CHECK constraints for all business rules",
      "currentState": "No database-level constraints on financial or date fields",
      "desiredState": "CHECK constraints enforce data validity at database level",
      "implementation": "Create migration with CHECK constraints for amounts, dates, statuses",
      "priority": "HIGH"
    }
  ],

  "performanceImpactAnalysis": {
    "criticalBottlenecks": [
      {
        "issue": "Missing index on deletedAt in BaseEntity",
        "affectedTables": "All 107 entities with soft delete",
        "currentPerformance": "Full table scan on every query with WHERE deletedAt IS NULL",
        "estimatedQPS": "Hundreds of queries per second affected",
        "estimatedImpact": "80-95% query time reduction with index",
        "priority": "IMMEDIATE - FIX IN NEXT RELEASE"
      },
      {
        "issue": "N+1 queries on time entry -> user relationship",
        "affectedQueries": "Timesheet listings, billing reports",
        "currentPerformance": "1 + N queries where N = number of time entries",
        "estimatedQPS": "50-100 queries per timesheet page load",
        "estimatedImpact": "95% reduction in queries with eager loading",
        "priority": "HIGH"
      },
      {
        "issue": "Missing composite index on sessions(user_id, is_active, expires_at)",
        "affectedQueries": "Session validation on every API request",
        "currentPerformance": "Sequential scans or inefficient index usage",
        "estimatedQPS": "ALL API requests (thousands per second)",
        "estimatedImpact": "70-80% reduction in session lookup time",
        "priority": "HIGH"
      }
    ],
    "scalabilityProjections": {
      "currentState": "Can support ~500 concurrent users with current schema",
      "withRecommendedIndexes": "Can support 2000-3000 concurrent users",
      "withAllOptimizations": "Can support 5000+ concurrent users",
      "databaseSize10Years": "Estimated 500GB-1TB with current audit log retention",
      "recommendations": "Implement table partitioning for audit_logs after 1M records"
    }
  },

  "complianceAndSecurity": {
    "strengths": [
      "Row-level security enabled on users table",
      "SSL/TLS encryption enforced with certificate validation",
      "Audit logging comprehensive with tamper detection (hash chains)",
      "Prepared statement caching prevents SQL injection",
      "Connection encryption with client certificates supported",
      "Query timeout limits prevent denial of service"
    ],
    "concerns": [
      {
        "issue": "Document cascade delete violates legal hold requirements",
        "regulation": "FRCP, state bar ethics rules",
        "risk": "Deletion of documents under legal hold",
        "recommendation": "Replace CASCADE with soft delete + legal hold flag check"
      },
      {
        "issue": "No encryption at rest for sensitive fields",
        "regulation": "GDPR, CCPA, state privacy laws",
        "risk": "Exposure of PII in database dumps",
        "recommendation": "Implement column-level encryption for SSN, financial accounts"
      },
      {
        "issue": "Audit log retention not automated",
        "regulation": "SOC 2, legal ethics rules",
        "risk": "Indefinite storage or premature deletion",
        "recommendation": "Implement automated archival after retention_period_days"
      }
    ]
  },

  "prioritizedActionPlan": {
    "phase1_immediate": {
      "timeline": "Within 1 week",
      "actions": [
        "Change synchronize: false in data-source.ts",
        "Add index on deletedAt in BaseEntity",
        "Create and run AddCriticalIndexes migration",
        "Fix Custodian and TrustAccount to extend BaseEntity",
        "Remove duplicate createdBy/updatedBy from Invoice and Document entities"
      ],
      "estimatedEffort": "8-12 hours",
      "riskMitigation": "Test all changes in staging environment, run migrations during maintenance window"
    },
    "phase2_highPriority": {
      "timeline": "Within 1 month",
      "actions": [
        "Enable SnakeNamingStrategy and standardize naming",
        "Add composite indexes for common query patterns",
        "Create AddFinancialConstraints migration",
        "Fix Evidence entity enum types",
        "Implement eager loading for high-frequency relationships",
        "Add CHECK constraints for business rules"
      ],
      "estimatedEffort": "40-60 hours",
      "riskMitigation": "Incremental deployment, comprehensive testing"
    },
    "phase3_optimization": {
      "timeline": "Within 3 months",
      "actions": [
        "Implement table partitioning for audit_logs",
        "Add covering indexes with INCLUDE clause",
        "Optimize cascade delete patterns",
        "Implement automated index maintenance",
        "Add GIN indexes for JSONB columns",
        "Create materialized views for complex reports"
      ],
      "estimatedEffort": "80-120 hours",
      "riskMitigation": "Performance testing at each step"
    }
  }
}
